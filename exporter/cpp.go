package exporter



// // CppExporter implements code generation for C++
// type CppExporter struct {
// 	BaseExporter
// }

// // NewCppExporter creates a new C++ exporter
// func NewCppExporter() Exporter {
// 	return &CppExporter{
// 		BaseExporter: NewBaseExporter("cpp"),
// 	}
// }

// // Export implements the Exporter interface
// func (e *CppExporter) Export(tables []Table, opts Options) error {

// 	// Generate header files
// 	if err := e.generateHeaders(tables, opts); err != nil {
// 		return fmt.Errorf("failed to generate headers: %v", err)
// 	}

// 	// Generate implementation files
// 	if err := e.generateImplementations(tables, opts); err != nil {
// 		return fmt.Errorf("failed to generate implementations: %v", err)
// 	}

// 	// Generate database schema
// 	if err := e.generateDatabaseSchema(tables, opts); err != nil {
// 		return fmt.Errorf("failed to generate schema: %v", err)
// 	}

// 	return nil
// }

// func (e *CppExporter) generateHeaders(tables []Table, opts Options) error {
// 	const headerTemplate = `// Code generated by excelite. DO NOT EDIT.
// #pragma once

// #include <string>
// #include <vector>
// #include <memory>
// #include <sqlite3.h>
// #include <optional>
// #include <chrono>

// namespace {{.PackageName}} {

// {{range .Tables}}
// class {{.Name}} {
// public:
//     {{.Name}}();
//     ~{{.Name}}();

//     // Getters and setters
//     {{range .Columns}}
//     const {{.CppType}}& get{{.CapitalizedName}}() const { return {{.Name}}; }
//     void set{{.CapitalizedName}}(const {{.CppType}}& value) { {{.Name}} = value; }
//     {{end}}

//     // Database operations
//     bool save(sqlite3* db);
//     static std::optional<{{.Name}}> findById(sqlite3* db, int64_t id);
//     static std::vector<{{.Name}}> findAll(sqlite3* db);
//     bool remove(sqlite3* db);

//     // Relationship accessors
//     {{range .Relations}}
//     {{if eq .RelationType "hasOne"}}
//     std::optional<{{.TargetTable}}> get{{.TargetTable}}(sqlite3* db) const;
//     {{else if eq .RelationType "hasMany"}}
//     std::vector<{{.TargetTable}}> get{{.TargetTable}}List(sqlite3* db) const;
//     {{end}}
//     {{end}}

// private:
//     {{range .Columns}}
//     {{.CppType}} {{.Name}};
//     {{end}}

//     static constexpr const char* TABLE_NAME = "{{.TableName}}";
// };
// {{end}}

// } // namespace {{.PackageName}}
// `
// 	tmpl, err := template.New("header").Parse(headerTemplate)
// 	if err != nil {
// 		return err
// 	}

// 	for _, table := range tables {
// 		var buf bytes.Buffer
// 		data := struct {
// 			PackageName string
// 			Table       Table
// 		}{
// 			PackageName: opts.PackageName,
// 			Table:       table,
// 		}

// 		if err := tmpl.Execute(&buf, data); err != nil {
// 			return err
// 		}

// 		outputFile := filepath.Join(opts.OutputDir, fmt.Sprintf("%s.h", table.Name))
// 		if err := os.WriteFile(outputFile, buf.Bytes(), 0644); err != nil {
// 			return err
// 		}
// 	}

// 	return nil
// }

// func (e *CppExporter) generateImplementations(tables []Table, opts Options) error {
// 	const implTemplate = `// Code generated by excelite. DO NOT EDIT.
// #include "{{.Table.Name}}.h"
// #include <sstream>
// #include <string>

// namespace {{.PackageName}} {

// {{.Table.Name}}::{{.Table.Name}}() = default;
// {{.Table.Name}}::~{{.Table.Name}}() = default;

// bool {{.Table.Name}}::save(sqlite3* db) {
//     const char* sql = R"(
//         INSERT OR REPLACE INTO {{.Table.TableName}} (
//             {{range .Table.Columns}}{{.Name}},{{end}}
//             created_at,
//             updated_at
//         ) VALUES (
//             {{range .Table.Columns}}?,{{end}}
//             datetime('now'),
//             datetime('now')
//         )
//     )";

//     sqlite3_stmt* stmt;
//     if (sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr) != SQLITE_OK) {
//         return false;
//     }

//     int idx = 1;
//     {{range .Table.Columns}}
//     if (auto err = sqlite3_bind_{{.SQLiteType}}(stmt, idx++, {{.Name}}); err != SQLITE_OK) {
//         sqlite3_finalize(stmt);
//         return false;
//     }
//     {{end}}

//     bool success = sqlite3_step(stmt) == SQLITE_DONE;
//     sqlite3_finalize(stmt);
//     return success;
// }

// std::optional<{{.Table.Name}}> {{.Table.Name}}::findById(sqlite3* db, int64_t id) {
//     const char* sql = R"(
//         SELECT {{range .Table.Columns}}{{.Name}},{{end}}
//         FROM {{.Table.TableName}} 
//         WHERE id = ? AND deleted_at IS NULL
//     )";

//     sqlite3_stmt* stmt;
//     if (sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr) != SQLITE_OK) {
//         return std::nullopt;
//     }

//     sqlite3_bind_int64(stmt, 1, id);

//     {{.Table.Name}} result;
//     bool found = false;
    
//     if (sqlite3_step(stmt) == SQLITE_ROW) {
//         int idx = 0;
//         {{range .Table.Columns}}
//         result.set{{.CapitalizedName}}(sqlite3_column_{{.SQLiteType}}(stmt, idx++));
//         {{end}}
//         found = true;
//     }

//     sqlite3_finalize(stmt);
//     return found ? std::optional<{{.Table.Name}}>(result) : std::nullopt;
// }

// std::vector<{{.Table.Name}}> {{.Table.Name}}::findAll(sqlite3* db) {
//     std::vector<{{.Table.Name}}> results;
    
//     const char* sql = R"(
//         SELECT {{range .Table.Columns}}{{.Name}},{{end}}
//         FROM {{.Table.TableName}}
//         WHERE deleted_at IS NULL
//     )";

//     sqlite3_stmt* stmt;
//     if (sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr) != SQLITE_OK) {
//         return results;
//     }

//     while (sqlite3_step(stmt) == SQLITE_ROW) {
//         {{.Table.Name}} row;
//         int idx = 0;
//         {{range .Table.Columns}}
//         row.set{{.CapitalizedName}}(sqlite3_column_{{.SQLiteType}}(stmt, idx++));
//         {{end}}
//         results.push_back(row);
//     }

//     sqlite3_finalize(stmt);
//     return results;
// }

// bool {{.Table.Name}}::remove(sqlite3* db) {
//     const char* sql = R"(
//         UPDATE {{.Table.TableName}}
//         SET deleted_at = datetime('now')
//         WHERE id = ?
//     )";

//     sqlite3_stmt* stmt;
//     if (sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr) != SQLITE_OK) {
//         return false;
//     }

//     sqlite3_bind_int64(stmt, 1, getId());

//     bool success = sqlite3_step(stmt) == SQLITE_DONE;
//     sqlite3_finalize(stmt);
//     return success;
// }

// {{range .Table.Relations}}
// {{if eq .RelationType "hasOne"}}
// std::optional<{{.TargetTable}}> {{$.Table.Name}}::get{{.TargetTable}}(sqlite3* db) const {
//     return {{.TargetTable}}::findById(db, get{{.ForeignKey}}());
// }
// {{else if eq .RelationType "hasMany"}}
// std::vector<{{.TargetTable}}> {{$.Table.Name}}::get{{.TargetTable}}List(sqlite3* db) const {
//     const char* sql = R"(
//         SELECT {{range .Columns}}{{.Name}},{{end}}
//         FROM {{.TableName}}
//         WHERE {{.ForeignKey}} = ? AND deleted_at IS NULL
//     )";

//     sqlite3_stmt* stmt;
//     if (sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr) != SQLITE_OK) {
//         return {};
//     }

//     sqlite3_bind_int64(stmt, 1, getId());

//     std::vector<{{.TargetTable}}> results;
//     while (sqlite3_step(stmt) == SQLITE_ROW) {
//         {{.TargetTable}} row;
//         int idx = 0;
//         {{range .Columns}}
//         row.set{{.CapitalizedName}}(sqlite3_column_{{.SQLiteType}}(stmt, idx++));
//         {{end}}
//         results.push_back(row);
//     }

//     sqlite3_finalize(stmt);
//     return results;
// }
// {{end}}
// {{end}}

// } // namespace {{.PackageName}}
// `
// 	tmpl, err := template.New("implementation").Parse(implTemplate)
// 	if err != nil {
// 		return err
// 	}

// 	for _, table := range tables {
// 		var buf bytes.Buffer
// 		data := struct {
// 			PackageName string
// 			Table       Table
// 		}{
// 			PackageName: opts.PackageName,
// 			Table:       table,
// 		}

// 		if err := tmpl.Execute(&buf, data); err != nil {
// 			return err
// 		}

// 		outputFile := filepath.Join(opts.OutputDir, fmt.Sprintf("%s.cpp", table.Name))
// 		if err := os.WriteFile(outputFile, buf.Bytes(), 0644); err != nil {
// 			return err
// 		}
// 	}

// 	return nil
// }

// func (e *CppExporter) generateDatabaseSchema(tables []Table, opts Options) error {
// 	const schemaTemplate = `-- Database schema for {{.PackageName}}

// {{range .Tables}}
// CREATE TABLE IF NOT EXISTS {{.TableName}} (
//     id INTEGER PRIMARY KEY AUTOINCREMENT,
//     {{range .Columns}}
//     {{.Name}} {{.SQLType}}{{if .IsUnique}} UNIQUE{{end}},
//     {{end}}
//     created_at DATETIME NOT NULL,
//     updated_at DATETIME NOT NULL,
//     deleted_at DATETIME
// );

// {{range .Indices}}
// CREATE INDEX IF NOT EXISTS idx_{{$.Table.TableName}}_{{.Name}} ON {{$.Table.TableName}} ({{.Columns}});
// {{end}}
// {{end}}
// `
// 	tmpl, err := template.New("schema").Parse(schemaTemplate)
// 	if err != nil {
// 		return err
// 	}

// 	var buf bytes.Buffer
// 	data := struct {
// 		PackageName string
// 		Tables      []Table
// 	}{
// 		PackageName: opts.PackageName,
// 		Tables:      tables,
// 	}

// 	if err := tmpl.Execute(&buf, data); err != nil {
// 		return err
// 	}

// 	outputFile := filepath.Join(opts.OutputDir, "schema.sql")
// 	return os.WriteFile(outputFile, buf.Bytes(), 0644)
// }

// // Helper types and methods for C++ code generation
// type CppTypeConverter interface {
// 	ToCppType(column Column) string
// 	ToSQLiteType(column Column) string
// 	ToSQLType(column Column) string
// }

// type DefaultCppTypeConverter struct{}

// func (c DefaultCppTypeConverter) ToCppType(column Column) string {
// 	baseType := column.Type
// 	if column.IsArray {
// 		return fmt.Sprintf("std::vector<%s>", baseType)
// 	}

// 	switch baseType {
// 	case "string":
// 		return "std::string"
// 	case "int", "int32":
// 		return "int32_t"
// 	case "int64":
// 		return "int64_t"
// 	case "float":
// 		return "float"
// 	case "double":
// 		return "double"
// 	case "bool":
// 		return "bool"
// 	case "datetime":
// 		return "std::chrono::system_clock::time_point"
// 	default:
// 		return "std::string"
// 	}
// }

// func (c DefaultCppTypeConverter) ToSQLiteType(column Column) string {
// 	baseType := column.Type
// 	switch baseType {
// 	case "string":
// 		return "text"
// 	case "int", "int32", "int64":
// 		return "int64"
// 	case "float", "double":
// 		return "double"
// 	case "bool":
// 		return "int"
// 	case "datetime":
// 		return "text"
// 	default:
// 		return "text"
// 	}
// }

// func (c DefaultCppTypeConverter) ToSQLType(column Column) string {
// 	baseType := column.Type
// 	switch baseType {
// 	case "string":
// 		return "TEXT"
// 	case "int", "int32":
// 		return "INTEGER"
// 	case "int64":
// 		return "BIGINT"
// 	case "float":
// 		return "REAL"
// 	case "double":
// 		return "DOUBLE"
// 	case "bool":
// 		return "BOOLEAN"
// 	case "datetime":
// 		return "DATETIME"
// 	default:
// 		return "TEXT"
// 	}
// }
