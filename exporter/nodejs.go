// exporter/nodejs.go
package exporter


// // NodeJSExporter implements code generation for Node.js/TypeScript
// type NodeJSExporter struct {
// 	BaseExporter
// }

// func NewNodeJSExporter() Exporter {
// 	return &NodeJSExporter{
// 		BaseExporter: NewBaseExporter("nodejs"),
// 	}
// }

// func (e *NodeJSExporter) Export(tables []Table, opts Options) error {
// 	// TypeScript/TypeORM 사용 여부 확인
// 	useTypeScript := e.GetBoolOption(opts, "useTypeScript", true)
// 	useTypeORM := e.GetBoolOption(opts, "useTypeORM", true)

// 	// 1. 출력 디렉토리 생성
// 	if err := os.MkdirAll(opts.OutputDir, 0755); err != nil {
// 		return fmt.Errorf("failed to create output directory: %v", err)
// 	}

// 	// 2. 인터페이스 생성 (TypeScript)
// 	if useTypeScript {
// 		if err := e.generateInterfaces(tables, opts); err != nil {
// 			return fmt.Errorf("failed to generate interfaces: %v", err)
// 		}
// 	}

// 	// 3. 엔티티/모델 생성
// 	if err := e.generateEntities(tables, opts, useTypeScript, useTypeORM); err != nil {
// 		return fmt.Errorf("failed to generate entities: %v", err)
// 	}

// 	// 4. 저장소 생성
// 	if err := e.generateRepositories(tables, opts, useTypeScript); err != nil {
// 		return fmt.Errorf("failed to generate repositories: %v", err)
// 	}

// 	// 5. 마이그레이션 파일 생성
// 	if e.GetBoolOption(opts, "generateMigrations", true) {
// 		if err := e.generateMigrations(tables, opts); err != nil {
// 			return fmt.Errorf("failed to generate migrations: %v", err)
// 		}
// 	}

// 	return nil
// }

// func (e *NodeJSExporter) generateInterfaces(tables []Table, opts Options) error {
// 	const interfaceTemplate = `// Code generated by excelite. DO NOT EDIT.

// export interface Base {
//     id?: number;
//     createdAt?: Date;
//     updatedAt?: Date;
//     deletedAt?: Date | null;
// }

// {{range .Tables}}
// export interface I{{.Name}} extends Base {
//     {{range .Columns}}
//     {{.Name}}{{if not .Required}}?{{end}}: {{.TSType}};
//     {{end}}

//     {{range .Relations}}
//     {{if eq .RelationType "hasOne"}}
//     {{.TargetTable}}?: I{{.TargetTable}};
//     {{else if eq .RelationType "hasMany"}}
//     {{.TargetTable}}List?: I{{.TargetTable}}[];
//     {{end}}
//     {{end}}
// }
// {{end}}`

// 	tmpl, err := template.New("interfaces").Parse(interfaceTemplate)
// 	if err != nil {
// 		return err
// 	}

// 	data := struct {
// 		Tables []Table
// 	}{
// 		Tables: tables,
// 	}

// 	var buf bytes.Buffer
// 	if err := tmpl.Execute(&buf, data); err != nil {
// 		return err
// 	}

// 	outputFile := filepath.Join(opts.OutputDir, "interfaces.ts")
// 	return os.WriteFile(outputFile, buf.Bytes(), 0644)
// }

// func (e *NodeJSExporter) generateEntities(tables []Table, opts Options, useTS, useTypeORM bool) error {
// 	const entityTemplate = `{{if .UseTypeORM}}import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, DeleteDateColumn{{range .Decorators}}, {{.}}{{end}} } from "typeorm";{{end}}
// {{if .UseTypeScript}}import { I{{.Name}} } from "./interfaces";{{end}}

// {{if .UseTypeORM}}@Entity("{{.TableName}}"){{end}}
// export class {{.Name}}{{if .UseTypeScript}} implements I{{.Name}}{{end}} {
//     {{if .UseTypeORM}}@PrimaryGeneratedColumn(){{end}}
//     id!: number;

//     {{range .Columns}}
//     {{if $.UseTypeORM}}@Column({{.TypeORMOptions}}){{end}}
//     {{.Name}}{{if not .Required}}?{{end}}: {{.TSType}};
//     {{end}}

//     {{range .Relations}}
//     {{if eq .RelationType "hasOne"}}
//     {{if $.UseTypeORM}}@OneToOne(() => {{.TargetTable}})
//     @JoinColumn(){{end}}
//     {{.TargetTable}}?: {{.TargetTable}};
//     {{else if eq .RelationType "hasMany"}}
//     {{if $.UseTypeORM}}@OneToMany(() => {{.TargetTable}}, {{.ForeignKey}} => {{.ForeignKey}}.{{.SourceTable}}){{end}}
//     {{.TargetTable}}List?: {{.TargetTable}}[];
//     {{end}}
//     {{end}}

//     {{if .UseTypeORM}}
//     @CreateDateColumn()
//     createdAt!: Date;

//     @UpdateDateColumn()
//     updatedAt!: Date;

//     @DeleteDateColumn()
//     deletedAt?: Date;
//     {{end}}

//     constructor(data?: Partial<{{if .UseTypeScript}}I{{.Name}}{{else}}{{.Name}}{{end}}>) {
//         if (data) {
//             Object.assign(this, data);
//         }
//     }
// }
// `

// 	for _, table := range tables {
// 		tmpl, err := template.New("entity").Parse(entityTemplate)
// 		if err != nil {
// 			return err
// 		}

// 		data := struct {
// 			Name          string
// 			TableName     string
// 			UseTypeORM    bool
// 			UseTypeScript bool
// 			Columns       []tsColumn
// 			Relations     []tsRelation
// 			Decorators    []string
// 		}{
// 			Name:          table.Name,
// 			TableName:     toSnakeCase(table.Name),
// 			UseTypeORM:    useTypeORM,
// 			UseTypeScript: useTS,
// 			Columns:       convertColumns(table.Columns),
// 			Relations:     convertRelations(table.Relations),
// 		}

// 		var buf bytes.Buffer
// 		if err := tmpl.Execute(&buf, data); err != nil {
// 			return err
// 		}

// 		extension := ".ts"
// 		outputFile := filepath.Join(opts.OutputDir, strings.ToLower(table.Name)+".entity"+extension)
// 		if err := os.WriteFile(outputFile, buf.Bytes(), 0644); err != nil {
// 			return err
// 		}
// 	}

// 	return nil
// }

// func (e *NodeJSExporter) generateRepositories(tables []Table, opts Options, useTS bool) error {
// 	const repoTemplate = `{{if .UseTypeScript}}import { I{{.Name}} } from "./interfaces";{{end}}
// import { {{.Name}} } from "./{{.LowerName}}.entity";
// import { DataSource, Repository } from "typeorm";

// export class {{.Name}}Repository {
//     private repository: Repository<{{.Name}}>;

//     constructor(dataSource: DataSource) {
//         this.repository = dataSource.getRepository({{.Name}});
//     }

//     async create(data: {{if .UseTypeScript}}Partial<I{{.Name}}>{{else}}any{{end}}): Promise<{{.Name}}> {
//         const entity = new {{.Name}}(data);
//         return this.repository.save(entity);
//     }

//     async findById(id: number): Promise<{{.Name}} | null> {
//         return this.repository.findOneBy({ id });
//     }

//     async findAll(): Promise<{{.Name}}[]> {
//         return this.repository.find();
//     }

//     async update(id: number, data: {{if .UseTypeScript}}Partial<I{{.Name}}>{{else}}any{{end}}): Promise<{{.Name}} | null> {
//         await this.repository.update(id, data);
//         return this.findById(id);
//     }

//     async delete(id: number): Promise<boolean> {
//         const result = await this.repository.softDelete(id);
//         return result.affected ? result.affected > 0 : false;
//     }

//     {{range .Relations}}
//     {{if eq .RelationType "hasOne"}}
//     async findWith{{.TargetTable}}(id: number): Promise<{{$.Name}} | null> {
//         return this.repository.findOne({
//             where: { id },
//             relations: ["{{.TargetTable}}"]
//         });
//     }
//     {{else if eq .RelationType "hasMany"}}
//     async findWith{{.TargetTable}}List(id: number): Promise<{{$.Name}} | null> {
//         return this.repository.findOne({
//             where: { id },
//             relations: ["{{.TargetTable}}List"]
//         });
//     }
//     {{end}}
//     {{end}}
// }
// `

// 	for _, table := range tables {
// 		tmpl, err := template.New("repository").Parse(repoTemplate)
// 		if err != nil {
// 			return err
// 		}

// 		data := struct {
// 			Name          string
// 			LowerName     string
// 			UseTypeScript bool
// 			Relations     []tsRelation
// 		}{
// 			Name:          table.Name,
// 			LowerName:     strings.ToLower(table.Name),
// 			UseTypeScript: useTS,
// 			Relations:     convertRelations(table.Relations),
// 		}

// 		var buf bytes.Buffer
// 		if err := tmpl.Execute(&buf, data); err != nil {
// 			return err
// 		}

// 		extension := ".ts"
// 		outputFile := filepath.Join(opts.OutputDir, strings.ToLower(table.Name)+".repository"+extension)
// 		if err := os.WriteFile(outputFile, buf.Bytes(), 0644); err != nil {
// 			return err
// 		}
// 	}

// 	return nil
// }

// func (e *NodeJSExporter) generateMigrations(tables []Table, opts Options) error {
// 	const migrationTemplate = `import { MigrationInterface, QueryRunner, Table } from "typeorm";

// export class InitialMigration implements MigrationInterface {
//     public async up(queryRunner: QueryRunner): Promise<void> {
//         {{range .Tables}}
//         await queryRunner.createTable(new Table({
//             name: "{{.TableName}}",
//             columns: [
//                 {
//                     name: "id",
//                     type: "int",
//                     isPrimary: true,
//                     isGenerated: true,
//                     generationStrategy: "increment",
//                 },
//                 {{range .Columns}}
//                 {
//                     name: "{{.Name}}",
//                     type: "{{.DBType}}",
//                     {{if .IsUnique}}isUnique: true,{{end}}
//                     {{if not .Required}}isNullable: true,{{end}}
//                 },
//                 {{end}}
//                 {
//                     name: "created_at",
//                     type: "timestamp",
//                     default: "now()",
//                 },
//                 {
//                     name: "updated_at",
//                     type: "timestamp",
//                     default: "now()",
//                 },
//                 {
//                     name: "deleted_at",
//                     type: "timestamp",
//                     isNullable: true,
//                 },
//             ],
//         }));
//         {{end}}
//     }

//     public async down(queryRunner: QueryRunner): Promise<void> {
//         {{range .Tables}}
//         await queryRunner.dropTable("{{.TableName}}");
//         {{end}}
//     }
// }
// `

// 	tmpl, err := template.New("migration").Parse(migrationTemplate)
// 	if err != nil {
// 		return err
// 	}

// 	data := struct {
// 		Tables []Table
// 	}{
// 		Tables: tables,
// 	}

// 	var buf bytes.Buffer
// 	if err := tmpl.Execute(&buf, data); err != nil {
// 		return err
// 	}

// 	timestamp := time.Now().Format("20060102150405")
// 	outputFile := filepath.Join(opts.OutputDir, fmt.Sprintf("%s-initial-migration.ts", timestamp))
// 	return os.WriteFile(outputFile, buf.Bytes(), 0644)
// }

// // Helper types and functions
// type tsColumn struct {
// 	Name           string
// 	TSType         string
// 	DBType         string
// 	Required       bool
// 	IsUnique       bool
// 	TypeORMOptions string
// }

// type tsRelation struct {
// 	RelationType string
// 	SourceTable  string
// 	TargetTable  string
// 	ForeignKey   string
// }

// func convertColumns(columns []Column) []tsColumn {
// 	result := make([]tsColumn, len(columns))
// 	for i, col := range columns {
// 		result[i] = tsColumn{
// 			Name:           col.Name,
// 			TSType:         getTSType(col.Type),
// 			DBType:         getDBType(col.Type),
// 			Required:       !contains(col.Tags, "nullable"),
// 			IsUnique:       col.IsUnique,
// 			TypeORMOptions: buildTypeORMOptions(col),
// 		}
// 	}
// 	return result
// }

// func convertRelations(relations []Relation) []tsRelation {
// 	result := make([]tsRelation, len(relations))
// 	for i, rel := range relations {
// 		result[i] = tsRelation{
// 			RelationType: rel.RelationType,
// 			SourceTable:  rel.SourceTable,
// 			TargetTable:  rel.TargetTable,
// 			ForeignKey:   rel.ForeignKey,
// 		}
// 	}
// 	return result
// }

// func getTSType(dbType string) string {
// 	switch strings.ToLower(dbType) {
// 	case "int", "integer", "int64":
// 		return "number"
// 	case "float", "real", "double":
// 		return "number"
// 	case "bool", "boolean":
// 		return "boolean"
// 	case "datetime":
// 		return "Date"
// 	default:
// 		return "string"
// 	}
// }

// func getDBType(dbType string) string {
// 	switch strings.ToLower(dbType) {
// 	case "int", "integer":
// 		return "integer"
// 	case "int64", "bigint":
// 		return "bigint"
// 	case "float", "real":
// 		return "float"
// 	case "double":
// 		return "double precision"
// 	case "bool", "boolean":
// 		return "boolean"
// 	case "datetime":
// 		return "timestamp"
// 	default:
// 		return "varchar"
// 	}
// }

// func buildTypeORMOptions(col Column) string {
// 	var opts []string

// 	// 타입 설정
// 	opts = append(opts, fmt.Sprintf(`type: "%s"`, getDBType(col.Type)))

// 	// 유니크 설정
// 	if col.IsUnique {
// 		opts = append(opts, "unique: true")
// 	}

// 	// Nullable 설정
// 	if contains(col.Tags, "nullable") {
// 		opts = append(opts, "nullable: true")
// 	}

// 	return fmt.Sprintf("{ %s }", strings.Join(opts, ", "))
// }

// func toSnakeCase(str string) string {
// 	var result strings.Builder
// 	for i, r := range str {
// 		if i > 0 && 'A' <= r && r <= 'Z' {
// 			result.WriteByte('_')
// 		}
// 		result.WriteRune(unicode.ToLower(r))
// 	}
// 	return result.String()
// }
