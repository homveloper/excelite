// exporter/golang.go
package exporter

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
	"time"
)

// GORMExporter implements code generation for Go
type GORMExporter struct {
	BaseExporter
}

func NewGORMExporter() Exporter {
	return &GORMExporter{
		BaseExporter: NewBaseExporter("go"),
	}
}

func (e *GORMExporter) Export(tables []Table, opts Options) error {
	// 1. 출력 디렉토리 생성
	if err := os.MkdirAll(opts.OutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}

	// 2. GORM 모델 생성
	if err := e.generateModels(tables, opts); err != nil {
		return fmt.Errorf("failed to generate models: %v", err)
	}

	return nil
}

func (e *GORMExporter) generateModels(tables []Table, opts Options) error {
	const modelTemplate = `// Code generated by excelite. DO NOT EDIT.
package {{.PackageName}}

import (
	"gorm.io/gorm"
	"time"
)

{{range .Tables}}
// {{.Name}} represents the {{.Name}} table
type {{.Name}} struct {
	gorm.Model
	{{range .Columns}}
	{{.Name}} {{.GoType}} {{.Tags}}
	{{end}}
}

{{if .HasArrayFields}}
// BeforeSave handles array field serialization
func (m *{{.Name}}) BeforeSave(tx *gorm.DB) error {
	{{range .ArrayFields}}
	// Handle {{.Name}} array
	if m.{{.Name}} != nil {
		for i, v := range m.{{.Name}} {
			fieldName := fmt.Sprintf("{{.Name}}_%d", i)
			tx.Statement.SetColumn(fieldName, v)
		}
	}
	{{end}}
	return nil
}

// AfterFind handles array field deserialization
func (m *{{.Name}}) AfterFind(tx *gorm.DB) error {
	{{range .ArrayFields}}
	// Initialize {{.Name}} array
	m.{{.Name}} = make([]{{.BaseType}}, 0)
	for i := 0; ; i++ {
		field := reflect.ValueOf(m).Elem().FieldByName(fmt.Sprintf("{{.Name}}_%d", i))
		if !field.IsValid() {
			break
		}
		if !field.IsZero() {
			m.{{.Name}} = append(m.{{.Name}}, field.Interface().({{.BaseType}}))
		}
	}
	{{end}}
	return nil
}
{{end}}
{{end}}
`

	type modelData struct {
		Name           string
		Columns        []goColumn
		Relations      []Relation
		HasArrayFields bool
		ArrayFields    []goArrayField
	}

	data := struct {
		PackageName string
		Tables      []modelData
	}{
		PackageName: opts.PackageName,
		Tables:      make([]modelData, len(tables)),
	}

	for i, table := range tables {
		var arrayFields []goArrayField
		columns := make([]goColumn, len(table.Columns))

		for j, col := range table.Columns {
			goType := getGoTypeFromColumnType(col.Type)

			if col.Type.IsArray {
				baseType := getGoTypeFromColumnType(*col.Type.BaseType)
				arrayFields = append(arrayFields, goArrayField{
					Name:     col.Name,
					BaseType: baseType,
				})
				goType = fmt.Sprintf("[]%s", baseType)
			}

			columns[j] = goColumn{
				Name:   col.Name,
				GoType: goType,
				Tags:   buildGormTags(col),
			}
		}

		data.Tables[i] = modelData{
			Name:           table.Name,
			Columns:        columns,
			Relations:      table.Relations,
			HasArrayFields: len(arrayFields) > 0,
			ArrayFields:    arrayFields,
		}
	}

	// 템플릿 실행
	tmpl, err := template.New("model").Parse(modelTemplate)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	// 파일 저장
	outputFile := filepath.Join(opts.OutputDir, "models.go")
	return os.WriteFile(outputFile, buf.Bytes(), 0644)
}

func (e *GORMExporter) generateDBSchema(tables []Table, opts Options) error {
	const schemaTemplate = `-- Code generated by excelite. DO NOT EDIT.

{{range .Tables}}
CREATE TABLE IF NOT EXISTS {{.TableName}} (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	{{range .Columns}}
	{{.Name}} {{.SQLType}}{{if .IsUnique}} UNIQUE{{end}},
	{{end}}
	created_at DATETIME NOT NULL,
	updated_at DATETIME NOT NULL,
	deleted_at DATETIME
);

{{range .Indices}}
CREATE INDEX IF NOT EXISTS idx_{{$.TableName}}_{{.Name}} ON {{$.TableName}}({{.Columns}});
{{end}}
{{end}}
`
	tmpl, err := template.New("schema").Parse(schemaTemplate)
	if err != nil {
		return err
	}

	data := struct {
		Tables []Table
	}{
		Tables: tables,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	outputFile := filepath.Join(opts.OutputDir, "schema.sql")
	return os.WriteFile(outputFile, buf.Bytes(), 0644)
}

// Helper structs and functions
type goColumn struct {
	Name   string
	GoType string
	Tags   string
}

type goArrayField struct {
	Name     string
	BaseType string
}

func getGoTypeFromColumnType(colType ColumnType) string {
	switch colType.Type.Kind() {
	case reflect.Int:
		return "int"
	case reflect.Int32:
		return "int32"
	case reflect.Int64:
		return "int64"
	case reflect.Float32:
		return "float32"
	case reflect.Float64:
		return "float64"
	case reflect.Bool:
		return "bool"
	case reflect.String:
		return "string"
	case reflect.Slice:
		if colType.Type.Elem().Kind() == reflect.Uint8 {
			return "[]byte"
		}
		return "string" // JSON serialized array
	default:
		// Special handling for time.Time
		if colType.Type == reflect.TypeOf(time.Time{}) {
			return "time.Time"
		}
		return "string"
	}
}

// buildGormTags generates GORM tag string from Column definition
func buildGormTags(col Column) string {
	var tags []string

	// 1. Type tag from ColumnType
	if col.Type.SQLType != "" {
		tags = append(tags, fmt.Sprintf("type:%s", col.Type.SQLType))
	}

	// 2. Size tag for array types (if needed)
	if col.Type.IsArray {
		tags = append(tags, "type:text") // Arrays are stored as JSON in text field
	}

	// 3. Process all tags with framework-specific conversion
	for _, tagValue := range col.Tags {
		if gormTag := tagValue.GetFrameworkTag(FrameworkGorm); gormTag != "" {
			tags = append(tags, gormTag)
		}
	}

	// 6. Generate final tag string
	if len(tags) > 0 {
		return fmt.Sprintf(`gorm:"%s"`, strings.Join(tags, ";"))
	}

	return ""
}

func getSQLType(dbType string) string {
	switch strings.ToLower(dbType) {
	case "int", "integer":
		return "integer"
	case "int64", "bigint":
		return "bigint"
	case "float", "real":
		return "real"
	case "bool", "boolean":
		return "boolean"
	case "datetime":
		return "datetime"
	case "string", "text", "varchar":
		return "text"
	default:
		return "text"
	}
}

// // Tag 정보를 파싱하고 GORM 태그로 변환하는 함수
// func parseTagToGORMTag(tags []string) (string, map[string]string) {
// 	tagKeyValue := make(map[string]string)
// 	gormTags := make([]string, 0)

// 	// 쉼표로 구분된 태그들을 처리
// 	for _, tag := range tags {

// 		// key=value 형태의 태그 처리
// 		if strings.Contains(tag, "=") {
// 			parts := strings.SplitN(tag, "=", 2)
// 			key := strings.TrimSpace(parts[0])
// 			value := strings.TrimSpace(parts[1])
// 			tagKeyValue[key] = value

// 			// GORM 태그로 변환
// 			switch key {
// 			case TagSize:
// 				gormTags = append(gormTags, fmt.Sprintf("size:%s", value))
// 			case TagDefault:
// 				gormTags = append(gormTags, fmt.Sprintf("default:%s", value))
// 			case TagForeignKey:
// 				gormTags = append(gormTags, fmt.Sprintf("foreignKey:%s", value))
// 			}
// 		} else {
// 			// 단일 태그 처리
// 			tagKeyValue[tag] = "true"

// 			// GORM 태그로 변환
// 			switch tag {
// 			case TagPrimaryKey:
// 				gormTags = append(gormTags, "primaryKey")
// 			case TagUnique:
// 				gormTags = append(gormTags, "unique")
// 			case TagIndex:
// 				gormTags = append(gormTags, "index")
// 			case TagNotNull:
// 				gormTags = append(gormTags, "not null")
// 			case TagAutoInc:
// 				gormTags = append(gormTags, "autoIncrement")
// 			}
// 		}
// 	}

// 	gormTag := ""
// 	if len(gormTags) > 0 {
// 		gormTag = fmt.Sprintf(`gorm:"%s"`, strings.Join(gormTags, ";"))
// 	}

// 	return gormTag, tagKeyValue
// }
